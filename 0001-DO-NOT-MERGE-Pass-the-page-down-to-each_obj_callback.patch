From 912c10ec29e568294730892dcc184f2f9c234b3d Mon Sep 17 00:00:00 2001
From: Matt Valentine-House <matt@eightbitraptor.com>
Date: Wed, 19 Jan 2022 15:31:32 +0000
Subject: [PATCH] [DO NOT MERGE] Pass the page down to each_obj_callback
 functions

---
 ext/objspace/objspace_dump.c | 14 +++++++++++++-
 gc.c                         |  7 ++++---
 gc.h                         |  4 ++--
 vm_method.c                  |  2 +-
 yjit_codegen.c               |  4 ++--
 5 files changed, 22 insertions(+), 9 deletions(-)

diff --git a/ext/objspace/objspace_dump.c b/ext/objspace/objspace_dump.c
index cf7acb5c6f..c7f8a9b843 100644
--- a/ext/objspace/objspace_dump.c
+++ b/ext/objspace/objspace_dump.c
@@ -35,6 +35,8 @@ struct dump_config {
     const char *root_category;
     VALUE cur_obj;
     VALUE cur_obj_klass;
+    uintptr_t cur_page;
+    size_t cur_page_slot_size;
     size_t cur_obj_references;
     unsigned int roots: 1;
     unsigned int full_heap: 1;
@@ -336,6 +338,7 @@ dump_object(VALUE obj, struct dump_config *dc)
     rb_io_t *fptr;
     ID flags[RB_OBJ_GC_FLAGS_MAX];
     size_t n, i;
+    struct heap_page *page = (struct heap_page *)dc->cur_page;
 
     if (SPECIAL_CONST_P(obj)) {
         dump_append_special_const(dc, obj);
@@ -360,6 +363,12 @@ dump_object(VALUE obj, struct dump_config *dc)
     dump_append(dc, obj_type(obj));
     dump_append(dc, "\"");
 
+    dump_append(dc, ", \"page\":");
+    dump_append_ref(dc, (VALUE)page);
+
+    dump_append(dc, ", \"slot_size\":");
+    dump_append_sizet(dc, dc->cur_page_slot_size);
+
     if (dc->cur_obj_klass) {
         dump_append(dc, ", \"class\":");
         dump_append_ref(dc, dc->cur_obj_klass);
@@ -532,11 +541,14 @@ dump_object(VALUE obj, struct dump_config *dc)
 }
 
 static int
-heap_i(void *vstart, void *vend, size_t stride, void *data)
+heap_i(void *vstart, void *vend, size_t stride, void * page, void *data)
 {
     struct dump_config *dc = (struct dump_config *)data;
+
     VALUE v = (VALUE)vstart;
     for (; v != (VALUE)vend; v += stride) {
+        dc->cur_page = (uintptr_t)page;
+        dc->cur_page_slot_size = stride;
         void *ptr = asan_poisoned_object_p(v);
         asan_unpoison_object(v, false);
 
diff --git a/gc.c b/gc.c
index 066ac69961..d83005172b 100644
--- a/gc.c
+++ b/gc.c
@@ -3509,7 +3509,8 @@ Init_gc_stress(void)
     gc_stress_set(objspace, ruby_initial_gc_stress);
 }
 
-typedef int each_obj_callback(void *, void *, size_t, void *);
+// this is heap start, heap end, slot size, and data struct pointer
+typedef int each_obj_callback(void *, void *, size_t, void *, void *);
 
 static void objspace_each_objects(rb_objspace_t *objspace, each_obj_callback *callback, void *data, bool protected);
 static void objspace_reachable_objects_from_root(rb_objspace_t *, void (func)(const char *, VALUE, void *), void *);
@@ -3596,7 +3597,7 @@ objspace_each_objects_try(VALUE arg)
             uintptr_t pstart = (uintptr_t)page->start;
             uintptr_t pend = pstart + (page->total_slots * size_pool->slot_size);
 
-            if ((*data->callback)((void *)pstart, (void *)pend, size_pool->slot_size, data->data)) {
+            if ((*data->callback)((void *)pstart, (void *)pend, size_pool->slot_size, page, data->data)) {
                 break;
             }
 
@@ -10475,7 +10476,7 @@ reachable_object_check_moved_i(VALUE ref, void *data)
 }
 
 static int
-heap_check_moved_i(void *vstart, void *vend, size_t stride, void *data)
+heap_check_moved_i(void *vstart, void *vend, size_t stride, void * page, void *data)
 {
     VALUE v = (VALUE)vstart;
     for (; v != (VALUE)vend; v += stride) {
diff --git a/gc.h b/gc.h
index 91d6e5787d..3da06b5498 100644
--- a/gc.h
+++ b/gc.h
@@ -129,11 +129,11 @@ int rb_objspace_internal_object_p(VALUE obj);
 int rb_objspace_marked_object_p(VALUE obj);
 
 void rb_objspace_each_objects(
-    int (*callback)(void *start, void *end, size_t stride, void *data),
+    int (*callback)(void *start, void *end, size_t stride, void * page, void *data),
     void *data);
 
 void rb_objspace_each_objects_without_setup(
-    int (*callback)(void *, void *, size_t, void *),
+    int (*callback)(void *, void *, size_t, void *, void *),
     void *data);
 
 RUBY_SYMBOL_EXPORT_END
diff --git a/vm_method.c b/vm_method.c
index b926654bdc..76519349f1 100644
--- a/vm_method.c
+++ b/vm_method.c
@@ -280,7 +280,7 @@ rb_clear_method_cache(VALUE klass_or_module, ID mid)
 void rb_cc_table_free(VALUE klass);
 
 static int
-invalidate_all_cc(void *vstart, void *vend, size_t stride, void *data)
+invalidate_all_cc(void *vstart, void *vend, size_t stride, void * page, void *data)
 {
     VALUE v = (VALUE)vstart;
     for (; v != (VALUE)vend; v += stride) {
diff --git a/yjit_codegen.c b/yjit_codegen.c
index 8b60b85be4..44490dfbd9 100644
--- a/yjit_codegen.c
+++ b/yjit_codegen.c
@@ -4880,7 +4880,7 @@ gen_opt_invokebuiltin_delegate(jitstate_t *jit, ctx_t *ctx, codeblock_t *cb)
     return YJIT_KEEP_COMPILING;
 }
 
-static int tracing_invalidate_all_i(void *vstart, void *vend, size_t stride, void *data);
+static int tracing_invalidate_all_i(void *vstart, void *vend, size_t stride, void *page, void *data);
 static void invalidate_all_blocks_for_tracing(const rb_iseq_t *iseq);
 
 // Invalidate all generated code and patch C method return code to contain
@@ -4939,7 +4939,7 @@ rb_yjit_tracing_invalidate_all(void)
 }
 
 static int
-tracing_invalidate_all_i(void *vstart, void *vend, size_t stride, void *data)
+tracing_invalidate_all_i(void *vstart, void *vend, size_t stride, void *page, void *data)
 {
     VALUE v = (VALUE)vstart;
     for (; v != (VALUE)vend; v += stride) {
-- 
2.34.1

